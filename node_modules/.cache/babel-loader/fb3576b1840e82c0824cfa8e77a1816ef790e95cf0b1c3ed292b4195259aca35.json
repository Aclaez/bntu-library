{"ast":null,"code":"import _slicedToArray from \"C:/Users/trs_user/Documents/my/bntu-library/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useMemo } from 'react';\nimport { useMediatedState } from '../useMediatedState';\nimport { useSyncedRef } from '../useSyncedRef';\nimport { resolveHookState } from \"../util/resolveHookState.js\";\n/**\n * Tracks a numeric value.\n *\n * @param initialValue The initial value of the counter.\n * @param max The maximum value the counter is allowed to reach.\n *            If `initialValue` is greater than `max`, then `max` is set as the initial value.\n * @param min The minimum value the counter is allowed to reach.\n *            If `initialValue` is smaller than `min`, then `min` is set as the initial value.\n */\nexport function useCounter() {\n  var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 ? arguments[1] : undefined;\n  var min = arguments.length > 2 ? arguments[2] : undefined;\n  var _useMediatedState = useMediatedState(initialValue, function (v) {\n      if (max !== undefined) {\n        v = Math.min(max, v);\n      }\n      if (min !== undefined) {\n        v = Math.max(min, v);\n      }\n      return v;\n    }),\n    _useMediatedState2 = _slicedToArray(_useMediatedState, 2),\n    state = _useMediatedState2[0],\n    setState = _useMediatedState2[1];\n  var stateRef = useSyncedRef(state);\n  return [state, useMemo(function () {\n    return {\n      get: function get() {\n        return stateRef.current;\n      },\n      set: setState,\n      dec: function dec() {\n        var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        setState(function (val) {\n          return val - resolveHookState(delta, val);\n        });\n      },\n      inc: function inc() {\n        var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        setState(function (val) {\n          return val + resolveHookState(delta, val);\n        });\n      },\n      reset: function reset() {\n        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialValue;\n        setState(function (v) {\n          return resolveHookState(val, v);\n        });\n      }\n    };\n  }, [initialValue, setState, stateRef])];\n}","map":{"version":3,"names":["useMemo","useMediatedState","useSyncedRef","resolveHookState","useCounter","initialValue","arguments","length","undefined","max","min","_useMediatedState","v","Math","_useMediatedState2","_slicedToArray","state","setState","stateRef","get","current","set","dec","delta","val","inc","reset"],"sources":["C:/Users/trs_user/Documents/my/bntu-library/node_modules/@react-hookz/web/esm/useCounter/index.js"],"sourcesContent":["import { useMemo } from 'react';\nimport { useMediatedState } from '../useMediatedState';\nimport { useSyncedRef } from '../useSyncedRef';\nimport { resolveHookState } from \"../util/resolveHookState.js\";\n/**\n * Tracks a numeric value.\n *\n * @param initialValue The initial value of the counter.\n * @param max The maximum value the counter is allowed to reach.\n *            If `initialValue` is greater than `max`, then `max` is set as the initial value.\n * @param min The minimum value the counter is allowed to reach.\n *            If `initialValue` is smaller than `min`, then `min` is set as the initial value.\n */\nexport function useCounter(initialValue = 0, max, min) {\n    const [state, setState] = useMediatedState(initialValue, (v) => {\n        if (max !== undefined) {\n            v = Math.min(max, v);\n        }\n        if (min !== undefined) {\n            v = Math.max(min, v);\n        }\n        return v;\n    });\n    const stateRef = useSyncedRef(state);\n    return [\n        state,\n        useMemo(() => ({\n            get: () => stateRef.current,\n            set: setState,\n            dec: (delta = 1) => {\n                setState((val) => val - resolveHookState(delta, val));\n            },\n            inc: (delta = 1) => {\n                setState((val) => val + resolveHookState(delta, val));\n            },\n            reset: (val = initialValue) => {\n                setState((v) => resolveHookState(val, v));\n            },\n        }), [initialValue, setState, stateRef]),\n    ];\n}\n"],"mappings":";AAAA,SAASA,OAAO,QAAQ,OAAO;AAC/B,SAASC,gBAAgB,QAAQ,qBAAqB;AACtD,SAASC,YAAY,QAAQ,iBAAiB;AAC9C,SAASC,gBAAgB,QAAQ,6BAA6B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAAA,EAA6B;EAAA,IAA5BC,YAAY,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAAEG,GAAG,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAAEE,GAAG,GAAAJ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EACjD,IAAAG,iBAAA,GAA0BV,gBAAgB,CAACI,YAAY,EAAE,UAACO,CAAC,EAAK;MAC5D,IAAIH,GAAG,KAAKD,SAAS,EAAE;QACnBI,CAAC,GAAGC,IAAI,CAACH,GAAG,CAACD,GAAG,EAAEG,CAAC,CAAC;MACxB;MACA,IAAIF,GAAG,KAAKF,SAAS,EAAE;QACnBI,CAAC,GAAGC,IAAI,CAACJ,GAAG,CAACC,GAAG,EAAEE,CAAC,CAAC;MACxB;MACA,OAAOA,CAAC;IACZ,CAAC,CAAC;IAAAE,kBAAA,GAAAC,cAAA,CAAAJ,iBAAA;IARKK,KAAK,GAAAF,kBAAA;IAAEG,QAAQ,GAAAH,kBAAA;EAStB,IAAMI,QAAQ,GAAGhB,YAAY,CAACc,KAAK,CAAC;EACpC,OAAO,CACHA,KAAK,EACLhB,OAAO,CAAC;IAAA,OAAO;MACXmB,GAAG,EAAE,SAAAA,IAAA;QAAA,OAAMD,QAAQ,CAACE,OAAO;MAAA;MAC3BC,GAAG,EAAEJ,QAAQ;MACbK,GAAG,EAAE,SAAAA,IAAA,EAAe;QAAA,IAAdC,KAAK,GAAAjB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;QACXW,QAAQ,CAAC,UAACO,GAAG;UAAA,OAAKA,GAAG,GAAGrB,gBAAgB,CAACoB,KAAK,EAAEC,GAAG,CAAC;QAAA,EAAC;MACzD,CAAC;MACDC,GAAG,EAAE,SAAAA,IAAA,EAAe;QAAA,IAAdF,KAAK,GAAAjB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;QACXW,QAAQ,CAAC,UAACO,GAAG;UAAA,OAAKA,GAAG,GAAGrB,gBAAgB,CAACoB,KAAK,EAAEC,GAAG,CAAC;QAAA,EAAC;MACzD,CAAC;MACDE,KAAK,EAAE,SAAAA,MAAA,EAAwB;QAAA,IAAvBF,GAAG,GAAAlB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGD,YAAY;QACtBY,QAAQ,CAAC,UAACL,CAAC;UAAA,OAAKT,gBAAgB,CAACqB,GAAG,EAAEZ,CAAC,CAAC;QAAA,EAAC;MAC7C;IACJ,CAAC;EAAA,CAAC,EAAE,CAACP,YAAY,EAAEY,QAAQ,EAAEC,QAAQ,CAAC,CAAC,CAC1C;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}