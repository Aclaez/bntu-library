{"ast":null,"code":"import _toConsumableArray from \"C:/Users/trs_user/Documents/my/bntu-library/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { useMemo, useRef } from 'react';\nimport { resolveHookState } from \"../util/resolveHookState.js\";\nimport { useRerender } from '../useRerender';\nimport { useSyncedRef } from '../useSyncedRef';\nexport function useList(initialList) {\n  var initial = useSyncedRef(initialList);\n  var list = useRef(resolveHookState(initial.current));\n  var rerender = useRerender();\n  var actions = useMemo(function () {\n    return {\n      set: function set(newList) {\n        list.current = resolveHookState(newList, list.current);\n        rerender();\n      },\n      push: function push() {\n        for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n          items[_key] = arguments[_key];\n        }\n        actions.set(function (currentList) {\n          return [].concat(_toConsumableArray(currentList), items);\n        });\n      },\n      updateAt: function updateAt(index, newItem) {\n        actions.set(function (currentList) {\n          var listCopy = _toConsumableArray(currentList);\n          listCopy[index] = newItem;\n          return listCopy;\n        });\n      },\n      insertAt: function insertAt(index, newItem) {\n        actions.set(function (currentList) {\n          var listCopy = _toConsumableArray(currentList);\n          if (index >= listCopy.length) {\n            listCopy[index] = newItem;\n          } else {\n            listCopy.splice(index, 0, newItem);\n          }\n          return listCopy;\n        });\n      },\n      update: function update(predicate, newItem) {\n        actions.set(function (currentList) {\n          return currentList.map(function (item) {\n            return predicate(item, newItem) ? newItem : item;\n          });\n        });\n      },\n      updateFirst: function updateFirst(predicate, newItem) {\n        var indexOfMatch = list.current.findIndex(function (item) {\n          return predicate(item, newItem);\n        });\n        var NO_MATCH = -1;\n        if (indexOfMatch > NO_MATCH) {\n          actions.updateAt(indexOfMatch, newItem);\n        }\n      },\n      upsert: function upsert(predicate, newItem) {\n        var indexOfMatch = list.current.findIndex(function (item) {\n          return predicate(item, newItem);\n        });\n        var NO_MATCH = -1;\n        if (indexOfMatch > NO_MATCH) {\n          actions.updateAt(indexOfMatch, newItem);\n        } else {\n          actions.push(newItem);\n        }\n      },\n      sort: function sort(compareFn) {\n        actions.set(function (currentList) {\n          return _toConsumableArray(currentList).sort(compareFn);\n        });\n      },\n      filter: function filter(callbackFn, thisArg) {\n        /*\n         We're implementing filter based on the Array.prototype.filter API, thus the API is not going\n         to change, and we can turn off the no-array-callback-reference rule. Also, the filter API\n         requires the thisArg, so we can turn off the no-array-method-this-argument-rule.\n        */\n        // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n        actions.set(function (currentList) {\n          return _toConsumableArray(currentList).filter(callbackFn, thisArg);\n        });\n      },\n      removeAt: function removeAt(index) {\n        actions.set(function (currentList) {\n          var listCopy = _toConsumableArray(currentList);\n          if (index < listCopy.length) {\n            listCopy.splice(index, 1);\n          }\n          return listCopy;\n        });\n      },\n      clear: function clear() {\n        return actions.set([]);\n      },\n      reset: function reset() {\n        return actions.set(_toConsumableArray(resolveHookState(initial.current)));\n      }\n    };\n  }, [initial, rerender]);\n  return [list.current, actions];\n}","map":{"version":3,"names":["useMemo","useRef","resolveHookState","useRerender","useSyncedRef","useList","initialList","initial","list","current","rerender","actions","set","newList","push","_len","arguments","length","items","Array","_key","currentList","concat","_toConsumableArray","updateAt","index","newItem","listCopy","insertAt","splice","update","predicate","map","item","updateFirst","indexOfMatch","findIndex","NO_MATCH","upsert","sort","compareFn","filter","callbackFn","thisArg","removeAt","clear","reset"],"sources":["C:/Users/trs_user/Documents/my/bntu-library/node_modules/@react-hookz/web/esm/useList/index.js"],"sourcesContent":["import { useMemo, useRef } from 'react';\nimport { resolveHookState } from \"../util/resolveHookState.js\";\nimport { useRerender } from '../useRerender';\nimport { useSyncedRef } from '../useSyncedRef';\nexport function useList(initialList) {\n    const initial = useSyncedRef(initialList);\n    const list = useRef(resolveHookState(initial.current));\n    const rerender = useRerender();\n    const actions = useMemo(() => ({\n        set: (newList) => {\n            list.current = resolveHookState(newList, list.current);\n            rerender();\n        },\n        push: (...items) => {\n            actions.set((currentList) => [...currentList, ...items]);\n        },\n        updateAt: (index, newItem) => {\n            actions.set((currentList) => {\n                const listCopy = [...currentList];\n                listCopy[index] = newItem;\n                return listCopy;\n            });\n        },\n        insertAt: (index, newItem) => {\n            actions.set((currentList) => {\n                const listCopy = [...currentList];\n                if (index >= listCopy.length) {\n                    listCopy[index] = newItem;\n                }\n                else {\n                    listCopy.splice(index, 0, newItem);\n                }\n                return listCopy;\n            });\n        },\n        update: (predicate, newItem) => {\n            actions.set((currentList) => currentList.map((item) => (predicate(item, newItem) ? newItem : item)));\n        },\n        updateFirst: (predicate, newItem) => {\n            const indexOfMatch = list.current.findIndex((item) => predicate(item, newItem));\n            const NO_MATCH = -1;\n            if (indexOfMatch > NO_MATCH) {\n                actions.updateAt(indexOfMatch, newItem);\n            }\n        },\n        upsert: (predicate, newItem) => {\n            const indexOfMatch = list.current.findIndex((item) => predicate(item, newItem));\n            const NO_MATCH = -1;\n            if (indexOfMatch > NO_MATCH) {\n                actions.updateAt(indexOfMatch, newItem);\n            }\n            else {\n                actions.push(newItem);\n            }\n        },\n        sort: (compareFn) => {\n            actions.set((currentList) => [...currentList].sort(compareFn));\n        },\n        filter: (callbackFn, thisArg) => {\n            /*\n             We're implementing filter based on the Array.prototype.filter API, thus the API is not going\n             to change, and we can turn off the no-array-callback-reference rule. Also, the filter API\n             requires the thisArg, so we can turn off the no-array-method-this-argument-rule.\n            */\n            // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n            actions.set((currentList) => [...currentList].filter(callbackFn, thisArg));\n        },\n        removeAt: (index) => {\n            actions.set((currentList) => {\n                const listCopy = [...currentList];\n                if (index < listCopy.length) {\n                    listCopy.splice(index, 1);\n                }\n                return listCopy;\n            });\n        },\n        clear: () => actions.set([]),\n        reset: () => actions.set([...resolveHookState(initial.current)]),\n    }), [initial, rerender]);\n    return [list.current, actions];\n}\n"],"mappings":";AAAA,SAASA,OAAO,EAAEC,MAAM,QAAQ,OAAO;AACvC,SAASC,gBAAgB,QAAQ,6BAA6B;AAC9D,SAASC,WAAW,QAAQ,gBAAgB;AAC5C,SAASC,YAAY,QAAQ,iBAAiB;AAC9C,OAAO,SAASC,OAAOA,CAACC,WAAW,EAAE;EACjC,IAAMC,OAAO,GAAGH,YAAY,CAACE,WAAW,CAAC;EACzC,IAAME,IAAI,GAAGP,MAAM,CAACC,gBAAgB,CAACK,OAAO,CAACE,OAAO,CAAC,CAAC;EACtD,IAAMC,QAAQ,GAAGP,WAAW,EAAE;EAC9B,IAAMQ,OAAO,GAAGX,OAAO,CAAC;IAAA,OAAO;MAC3BY,GAAG,EAAE,SAAAA,IAACC,OAAO,EAAK;QACdL,IAAI,CAACC,OAAO,GAAGP,gBAAgB,CAACW,OAAO,EAAEL,IAAI,CAACC,OAAO,CAAC;QACtDC,QAAQ,EAAE;MACd,CAAC;MACDI,IAAI,EAAE,SAAAA,KAAA,EAAc;QAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAVC,KAAK,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;UAALF,KAAK,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;QAAA;QACXT,OAAO,CAACC,GAAG,CAAC,UAACS,WAAW;UAAA,UAAAC,MAAA,CAAAC,kBAAA,CAASF,WAAW,GAAKH,KAAK;QAAA,CAAC,CAAC;MAC5D,CAAC;MACDM,QAAQ,EAAE,SAAAA,SAACC,KAAK,EAAEC,OAAO,EAAK;QAC1Bf,OAAO,CAACC,GAAG,CAAC,UAACS,WAAW,EAAK;UACzB,IAAMM,QAAQ,GAAAJ,kBAAA,CAAOF,WAAW,CAAC;UACjCM,QAAQ,CAACF,KAAK,CAAC,GAAGC,OAAO;UACzB,OAAOC,QAAQ;QACnB,CAAC,CAAC;MACN,CAAC;MACDC,QAAQ,EAAE,SAAAA,SAACH,KAAK,EAAEC,OAAO,EAAK;QAC1Bf,OAAO,CAACC,GAAG,CAAC,UAACS,WAAW,EAAK;UACzB,IAAMM,QAAQ,GAAAJ,kBAAA,CAAOF,WAAW,CAAC;UACjC,IAAII,KAAK,IAAIE,QAAQ,CAACV,MAAM,EAAE;YAC1BU,QAAQ,CAACF,KAAK,CAAC,GAAGC,OAAO;UAC7B,CAAC,MACI;YACDC,QAAQ,CAACE,MAAM,CAACJ,KAAK,EAAE,CAAC,EAAEC,OAAO,CAAC;UACtC;UACA,OAAOC,QAAQ;QACnB,CAAC,CAAC;MACN,CAAC;MACDG,MAAM,EAAE,SAAAA,OAACC,SAAS,EAAEL,OAAO,EAAK;QAC5Bf,OAAO,CAACC,GAAG,CAAC,UAACS,WAAW;UAAA,OAAKA,WAAW,CAACW,GAAG,CAAC,UAACC,IAAI;YAAA,OAAMF,SAAS,CAACE,IAAI,EAAEP,OAAO,CAAC,GAAGA,OAAO,GAAGO,IAAI;UAAA,CAAC,CAAC;QAAA,EAAC;MACxG,CAAC;MACDC,WAAW,EAAE,SAAAA,YAACH,SAAS,EAAEL,OAAO,EAAK;QACjC,IAAMS,YAAY,GAAG3B,IAAI,CAACC,OAAO,CAAC2B,SAAS,CAAC,UAACH,IAAI;UAAA,OAAKF,SAAS,CAACE,IAAI,EAAEP,OAAO,CAAC;QAAA,EAAC;QAC/E,IAAMW,QAAQ,GAAG,CAAC,CAAC;QACnB,IAAIF,YAAY,GAAGE,QAAQ,EAAE;UACzB1B,OAAO,CAACa,QAAQ,CAACW,YAAY,EAAET,OAAO,CAAC;QAC3C;MACJ,CAAC;MACDY,MAAM,EAAE,SAAAA,OAACP,SAAS,EAAEL,OAAO,EAAK;QAC5B,IAAMS,YAAY,GAAG3B,IAAI,CAACC,OAAO,CAAC2B,SAAS,CAAC,UAACH,IAAI;UAAA,OAAKF,SAAS,CAACE,IAAI,EAAEP,OAAO,CAAC;QAAA,EAAC;QAC/E,IAAMW,QAAQ,GAAG,CAAC,CAAC;QACnB,IAAIF,YAAY,GAAGE,QAAQ,EAAE;UACzB1B,OAAO,CAACa,QAAQ,CAACW,YAAY,EAAET,OAAO,CAAC;QAC3C,CAAC,MACI;UACDf,OAAO,CAACG,IAAI,CAACY,OAAO,CAAC;QACzB;MACJ,CAAC;MACDa,IAAI,EAAE,SAAAA,KAACC,SAAS,EAAK;QACjB7B,OAAO,CAACC,GAAG,CAAC,UAACS,WAAW;UAAA,OAAKE,kBAAA,CAAIF,WAAW,EAAEkB,IAAI,CAACC,SAAS,CAAC;QAAA,EAAC;MAClE,CAAC;MACDC,MAAM,EAAE,SAAAA,OAACC,UAAU,EAAEC,OAAO,EAAK;QAC7B;AACZ;AACA;AACA;AACA;QACY;QACAhC,OAAO,CAACC,GAAG,CAAC,UAACS,WAAW;UAAA,OAAKE,kBAAA,CAAIF,WAAW,EAAEoB,MAAM,CAACC,UAAU,EAAEC,OAAO,CAAC;QAAA,EAAC;MAC9E,CAAC;MACDC,QAAQ,EAAE,SAAAA,SAACnB,KAAK,EAAK;QACjBd,OAAO,CAACC,GAAG,CAAC,UAACS,WAAW,EAAK;UACzB,IAAMM,QAAQ,GAAAJ,kBAAA,CAAOF,WAAW,CAAC;UACjC,IAAII,KAAK,GAAGE,QAAQ,CAACV,MAAM,EAAE;YACzBU,QAAQ,CAACE,MAAM,CAACJ,KAAK,EAAE,CAAC,CAAC;UAC7B;UACA,OAAOE,QAAQ;QACnB,CAAC,CAAC;MACN,CAAC;MACDkB,KAAK,EAAE,SAAAA,MAAA;QAAA,OAAMlC,OAAO,CAACC,GAAG,CAAC,EAAE,CAAC;MAAA;MAC5BkC,KAAK,EAAE,SAAAA,MAAA;QAAA,OAAMnC,OAAO,CAACC,GAAG,CAAAW,kBAAA,CAAKrB,gBAAgB,CAACK,OAAO,CAACE,OAAO,CAAC,EAAE;MAAA;IACpE,CAAC;EAAA,CAAC,EAAE,CAACF,OAAO,EAAEG,QAAQ,CAAC,CAAC;EACxB,OAAO,CAACF,IAAI,CAACC,OAAO,EAAEE,OAAO,CAAC;AAClC"},"metadata":{},"sourceType":"module","externalDependencies":[]}