{"ast":null,"code":"import { useMemo, useRef } from 'react';\nimport { resolveHookState } from \"../util/resolveHookState.js\";\nimport { useRerender } from '../useRerender';\nimport { useSyncedRef } from '../useSyncedRef';\nexport function useList(initialList) {\n  const initial = useSyncedRef(initialList);\n  const list = useRef(resolveHookState(initial.current));\n  const rerender = useRerender();\n  const actions = useMemo(() => ({\n    set: newList => {\n      list.current = resolveHookState(newList, list.current);\n      rerender();\n    },\n    push: function () {\n      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n        items[_key] = arguments[_key];\n      }\n      actions.set(currentList => [...currentList, ...items]);\n    },\n    updateAt: (index, newItem) => {\n      actions.set(currentList => {\n        const listCopy = [...currentList];\n        listCopy[index] = newItem;\n        return listCopy;\n      });\n    },\n    insertAt: (index, newItem) => {\n      actions.set(currentList => {\n        const listCopy = [...currentList];\n        if (index >= listCopy.length) {\n          listCopy[index] = newItem;\n        } else {\n          listCopy.splice(index, 0, newItem);\n        }\n        return listCopy;\n      });\n    },\n    update: (predicate, newItem) => {\n      actions.set(currentList => currentList.map(item => predicate(item, newItem) ? newItem : item));\n    },\n    updateFirst: (predicate, newItem) => {\n      const indexOfMatch = list.current.findIndex(item => predicate(item, newItem));\n      const NO_MATCH = -1;\n      if (indexOfMatch > NO_MATCH) {\n        actions.updateAt(indexOfMatch, newItem);\n      }\n    },\n    upsert: (predicate, newItem) => {\n      const indexOfMatch = list.current.findIndex(item => predicate(item, newItem));\n      const NO_MATCH = -1;\n      if (indexOfMatch > NO_MATCH) {\n        actions.updateAt(indexOfMatch, newItem);\n      } else {\n        actions.push(newItem);\n      }\n    },\n    sort: compareFn => {\n      actions.set(currentList => [...currentList].sort(compareFn));\n    },\n    filter: (callbackFn, thisArg) => {\n      /*\n       We're implementing filter based on the Array.prototype.filter API, thus the API is not going\n       to change, and we can turn off the no-array-callback-reference rule. Also, the filter API\n       requires the thisArg, so we can turn off the no-array-method-this-argument-rule.\n      */\n      // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n      actions.set(currentList => [...currentList].filter(callbackFn, thisArg));\n    },\n    removeAt: index => {\n      actions.set(currentList => {\n        const listCopy = [...currentList];\n        if (index < listCopy.length) {\n          listCopy.splice(index, 1);\n        }\n        return listCopy;\n      });\n    },\n    clear: () => actions.set([]),\n    reset: () => actions.set([...resolveHookState(initial.current)])\n  }), [initial, rerender]);\n  return [list.current, actions];\n}","map":{"version":3,"names":["useMemo","useRef","resolveHookState","useRerender","useSyncedRef","useList","initialList","initial","list","current","rerender","actions","set","newList","push","_len","arguments","length","items","Array","_key","currentList","updateAt","index","newItem","listCopy","insertAt","splice","update","predicate","map","item","updateFirst","indexOfMatch","findIndex","NO_MATCH","upsert","sort","compareFn","filter","callbackFn","thisArg","removeAt","clear","reset"],"sources":["C:/Users/trs_user/Documents/my/bntu-library/node_modules/@react-hookz/web/esm/useList/index.js"],"sourcesContent":["import { useMemo, useRef } from 'react';\nimport { resolveHookState } from \"../util/resolveHookState.js\";\nimport { useRerender } from '../useRerender';\nimport { useSyncedRef } from '../useSyncedRef';\nexport function useList(initialList) {\n    const initial = useSyncedRef(initialList);\n    const list = useRef(resolveHookState(initial.current));\n    const rerender = useRerender();\n    const actions = useMemo(() => ({\n        set: (newList) => {\n            list.current = resolveHookState(newList, list.current);\n            rerender();\n        },\n        push: (...items) => {\n            actions.set((currentList) => [...currentList, ...items]);\n        },\n        updateAt: (index, newItem) => {\n            actions.set((currentList) => {\n                const listCopy = [...currentList];\n                listCopy[index] = newItem;\n                return listCopy;\n            });\n        },\n        insertAt: (index, newItem) => {\n            actions.set((currentList) => {\n                const listCopy = [...currentList];\n                if (index >= listCopy.length) {\n                    listCopy[index] = newItem;\n                }\n                else {\n                    listCopy.splice(index, 0, newItem);\n                }\n                return listCopy;\n            });\n        },\n        update: (predicate, newItem) => {\n            actions.set((currentList) => currentList.map((item) => (predicate(item, newItem) ? newItem : item)));\n        },\n        updateFirst: (predicate, newItem) => {\n            const indexOfMatch = list.current.findIndex((item) => predicate(item, newItem));\n            const NO_MATCH = -1;\n            if (indexOfMatch > NO_MATCH) {\n                actions.updateAt(indexOfMatch, newItem);\n            }\n        },\n        upsert: (predicate, newItem) => {\n            const indexOfMatch = list.current.findIndex((item) => predicate(item, newItem));\n            const NO_MATCH = -1;\n            if (indexOfMatch > NO_MATCH) {\n                actions.updateAt(indexOfMatch, newItem);\n            }\n            else {\n                actions.push(newItem);\n            }\n        },\n        sort: (compareFn) => {\n            actions.set((currentList) => [...currentList].sort(compareFn));\n        },\n        filter: (callbackFn, thisArg) => {\n            /*\n             We're implementing filter based on the Array.prototype.filter API, thus the API is not going\n             to change, and we can turn off the no-array-callback-reference rule. Also, the filter API\n             requires the thisArg, so we can turn off the no-array-method-this-argument-rule.\n            */\n            // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n            actions.set((currentList) => [...currentList].filter(callbackFn, thisArg));\n        },\n        removeAt: (index) => {\n            actions.set((currentList) => {\n                const listCopy = [...currentList];\n                if (index < listCopy.length) {\n                    listCopy.splice(index, 1);\n                }\n                return listCopy;\n            });\n        },\n        clear: () => actions.set([]),\n        reset: () => actions.set([...resolveHookState(initial.current)]),\n    }), [initial, rerender]);\n    return [list.current, actions];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}