{"ast":null,"code":"import { useEffect } from 'react';\nimport { useSyncedRef } from '../useSyncedRef';\nimport { isBrowser } from \"../util/const.js\";\nvar observerSingleton;\nfunction getResizeObserver() {\n  if (!isBrowser) return undefined;\n  if (observerSingleton) return observerSingleton;\n  var callbacks = new Map();\n  var observer = new ResizeObserver(function (entries) {\n    entries.forEach(function (entry) {\n      var _callbacks$get;\n      return (_callbacks$get = callbacks.get(entry.target)) === null || _callbacks$get === void 0 ? void 0 : _callbacks$get.forEach(function (cb) {\n        return setTimeout(function () {\n          return cb(entry);\n        }, 0);\n      });\n    });\n  });\n  observerSingleton = {\n    observer: observer,\n    subscribe: function subscribe(target, callback) {\n      var cbs = callbacks.get(target);\n      if (!cbs) {\n        // if target has no observers yet - register it\n        cbs = new Set();\n        callbacks.set(target, cbs);\n        observer.observe(target);\n      }\n      // as Set is duplicate-safe - simply add callback on each call\n      cbs.add(callback);\n    },\n    unsubscribe: function unsubscribe(target, callback) {\n      var cbs = callbacks.get(target);\n      // else branch should never occur in case of normal execution\n      // because callbacks map is hidden in closure - it is impossible to\n      // simulate situation with non-existent `cbs` Set\n      /* istanbul ignore else */\n      if (cbs) {\n        // remove current observer\n        cbs.delete(callback);\n        if (!cbs.size) {\n          // if no observers left unregister target completely\n          callbacks.delete(target);\n          observer.unobserve(target);\n        }\n      }\n    }\n  };\n  return observerSingleton;\n}\n/**\n * Invokes a callback whenever ResizeObserver detects a change to target's size.\n *\n * @param target React reference or Element to track.\n * @param callback Callback that will be invoked on resize.\n * @param enabled Whether resize observer is enabled or not.\n */\nexport function useResizeObserver(target, callback) {\n  var enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var ro = enabled && getResizeObserver();\n  var cb = useSyncedRef(callback);\n  var tgt = target && 'current' in target ? target.current : target;\n  useEffect(function () {\n    // this secondary target resolve required for case when we receive ref object, which, most\n    // likely, contains null during render stage, but already populated with element during\n    // effect stage.\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    var tgt = target && 'current' in target ? target.current : target;\n    if (!ro || !tgt) return;\n    // as unsubscription in internals of our ResizeObserver abstraction can\n    // happen a bit later than effect cleanup invocation - we need a marker,\n    // that this handler should not be invoked anymore\n    var subscribed = true;\n    var handler = function handler() {\n      // it is reinsurance for the highly asynchronous invocations, almost\n      // impossible to achieve in tests, thus excluding from LOC\n      /* istanbul ignore else */\n      if (subscribed) {\n        cb.current.apply(cb, arguments);\n      }\n    };\n    ro.subscribe(tgt, handler);\n    return function () {\n      subscribed = false;\n      ro.unsubscribe(tgt, handler);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [tgt, ro]);\n}","map":{"version":3,"names":["useEffect","useSyncedRef","isBrowser","observerSingleton","getResizeObserver","undefined","callbacks","Map","observer","ResizeObserver","entries","forEach","entry","_callbacks$get","get","target","cb","setTimeout","subscribe","callback","cbs","Set","set","observe","add","unsubscribe","delete","size","unobserve","useResizeObserver","enabled","arguments","length","ro","tgt","current","subscribed","handler","apply"],"sources":["C:/Users/trs_user/Documents/my/bntu-library/node_modules/@react-hookz/web/esm/useResizeObserver/index.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { useSyncedRef } from '../useSyncedRef';\nimport { isBrowser } from \"../util/const.js\";\nlet observerSingleton;\nfunction getResizeObserver() {\n    if (!isBrowser)\n        return undefined;\n    if (observerSingleton)\n        return observerSingleton;\n    const callbacks = new Map();\n    const observer = new ResizeObserver((entries) => {\n        entries.forEach((entry) => callbacks.get(entry.target)?.forEach((cb) => setTimeout(() => cb(entry), 0)));\n    });\n    observerSingleton = {\n        observer,\n        subscribe: (target, callback) => {\n            let cbs = callbacks.get(target);\n            if (!cbs) {\n                // if target has no observers yet - register it\n                cbs = new Set();\n                callbacks.set(target, cbs);\n                observer.observe(target);\n            }\n            // as Set is duplicate-safe - simply add callback on each call\n            cbs.add(callback);\n        },\n        unsubscribe: (target, callback) => {\n            const cbs = callbacks.get(target);\n            // else branch should never occur in case of normal execution\n            // because callbacks map is hidden in closure - it is impossible to\n            // simulate situation with non-existent `cbs` Set\n            /* istanbul ignore else */\n            if (cbs) {\n                // remove current observer\n                cbs.delete(callback);\n                if (!cbs.size) {\n                    // if no observers left unregister target completely\n                    callbacks.delete(target);\n                    observer.unobserve(target);\n                }\n            }\n        },\n    };\n    return observerSingleton;\n}\n/**\n * Invokes a callback whenever ResizeObserver detects a change to target's size.\n *\n * @param target React reference or Element to track.\n * @param callback Callback that will be invoked on resize.\n * @param enabled Whether resize observer is enabled or not.\n */\nexport function useResizeObserver(target, callback, enabled = true) {\n    const ro = enabled && getResizeObserver();\n    const cb = useSyncedRef(callback);\n    const tgt = target && 'current' in target ? target.current : target;\n    useEffect(() => {\n        // this secondary target resolve required for case when we receive ref object, which, most\n        // likely, contains null during render stage, but already populated with element during\n        // effect stage.\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const tgt = target && 'current' in target ? target.current : target;\n        if (!ro || !tgt)\n            return;\n        // as unsubscription in internals of our ResizeObserver abstraction can\n        // happen a bit later than effect cleanup invocation - we need a marker,\n        // that this handler should not be invoked anymore\n        let subscribed = true;\n        const handler = (...args) => {\n            // it is reinsurance for the highly asynchronous invocations, almost\n            // impossible to achieve in tests, thus excluding from LOC\n            /* istanbul ignore else */\n            if (subscribed) {\n                cb.current(...args);\n            }\n        };\n        ro.subscribe(tgt, handler);\n        return () => {\n            subscribed = false;\n            ro.unsubscribe(tgt, handler);\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [tgt, ro]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}