{"ast":null,"code":"import { useEffect, useState } from 'react';\nconst DEFAULT_THRESHOLD = [0];\nconst DEFAULT_ROOT_MARGIN = '0px';\nconst observers = new Map();\nconst getObserverEntry = options => {\n  const root = options.root ?? document;\n  let rootObservers = observers.get(root);\n  if (!rootObservers) {\n    rootObservers = new Map();\n    observers.set(root, rootObservers);\n  }\n  const opt = JSON.stringify([options.rootMargin, options.threshold]);\n  let entry = rootObservers.get(opt);\n  if (!entry) {\n    const callbacks = new Map();\n    const observer = new IntersectionObserver(entries => entries.forEach(e => callbacks.get(e.target)?.forEach(cb => setTimeout(() => cb(e), 0))), options);\n    entry = {\n      observer,\n      observe(target, callback) {\n        let cbs = callbacks.get(target);\n        if (!cbs) {\n          // if target has no observers yet - register it\n          cbs = new Set();\n          callbacks.set(target, cbs);\n          observer.observe(target);\n        }\n        // as Set is duplicate-safe - simply add callback on each call\n        cbs.add(callback);\n      },\n      unobserve(target, callback) {\n        const cbs = callbacks.get(target);\n        // else branch should never occur in case of normal execution\n        // because callbacks map is hidden in closure - it is impossible to\n        // simulate situation with non-existent `cbs` Set\n        /* istanbul ignore else */\n        if (cbs) {\n          // remove current observer\n          cbs.delete(callback);\n          if (!cbs.size) {\n            // if no observers left unregister target completely\n            callbacks.delete(target);\n            observer.unobserve(target);\n            // if not tracked elements left - disconnect observer\n            if (!callbacks.size) {\n              observer.disconnect();\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              rootObservers.delete(opt);\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              if (!rootObservers.size) {\n                observers.delete(root);\n              }\n            }\n          }\n        }\n      }\n    };\n    rootObservers.set(opt, entry);\n  }\n  return entry;\n};\n/**\n * Tracks intersection of a target element with an ancestor element or with a\n * top-level document's viewport.\n *\n * @param target React reference or Element to track.\n * @param options Like `IntersectionObserver` options but `root` can also be\n * react reference\n */\nexport function useIntersectionObserver(target) {\n  let {\n    threshold = DEFAULT_THRESHOLD,\n    root: r,\n    rootMargin = DEFAULT_ROOT_MARGIN\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const [state, setState] = useState();\n  useEffect(() => {\n    const tgt = target && 'current' in target ? target.current : target;\n    if (!tgt) return;\n    let subscribed = true;\n    const observerEntry = getObserverEntry({\n      root: r && 'current' in r ? r.current : r,\n      rootMargin,\n      threshold\n    });\n    const handler = entry => {\n      // it is reinsurance for the highly asynchronous invocations, almost\n      // impossible to achieve in tests, thus excluding from LOC\n      /* istanbul ignore else */\n      if (subscribed) {\n        setState(entry);\n      }\n    };\n    observerEntry.observe(tgt, handler);\n    return () => {\n      subscribed = false;\n      observerEntry.unobserve(tgt, handler);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [target, r, rootMargin, ...threshold]);\n  return state;\n}","map":{"version":3,"names":["useEffect","useState","DEFAULT_THRESHOLD","DEFAULT_ROOT_MARGIN","observers","Map","getObserverEntry","options","root","document","rootObservers","get","set","opt","JSON","stringify","rootMargin","threshold","entry","callbacks","observer","IntersectionObserver","entries","forEach","e","target","cb","setTimeout","observe","callback","cbs","Set","add","unobserve","delete","size","disconnect","useIntersectionObserver","r","arguments","length","undefined","state","setState","tgt","current","subscribed","observerEntry","handler"],"sources":["C:/Users/trs_user/Documents/my/bntu-library/node_modules/@react-hookz/web/esm/useIntersectionObserver/index.js"],"sourcesContent":["import { useEffect, useState } from 'react';\nconst DEFAULT_THRESHOLD = [0];\nconst DEFAULT_ROOT_MARGIN = '0px';\nconst observers = new Map();\nconst getObserverEntry = (options) => {\n    const root = options.root ?? document;\n    let rootObservers = observers.get(root);\n    if (!rootObservers) {\n        rootObservers = new Map();\n        observers.set(root, rootObservers);\n    }\n    const opt = JSON.stringify([options.rootMargin, options.threshold]);\n    let entry = rootObservers.get(opt);\n    if (!entry) {\n        const callbacks = new Map();\n        const observer = new IntersectionObserver((entries) => entries.forEach((e) => callbacks.get(e.target)?.forEach((cb) => setTimeout(() => cb(e), 0))), options);\n        entry = {\n            observer,\n            observe(target, callback) {\n                let cbs = callbacks.get(target);\n                if (!cbs) {\n                    // if target has no observers yet - register it\n                    cbs = new Set();\n                    callbacks.set(target, cbs);\n                    observer.observe(target);\n                }\n                // as Set is duplicate-safe - simply add callback on each call\n                cbs.add(callback);\n            },\n            unobserve(target, callback) {\n                const cbs = callbacks.get(target);\n                // else branch should never occur in case of normal execution\n                // because callbacks map is hidden in closure - it is impossible to\n                // simulate situation with non-existent `cbs` Set\n                /* istanbul ignore else */\n                if (cbs) {\n                    // remove current observer\n                    cbs.delete(callback);\n                    if (!cbs.size) {\n                        // if no observers left unregister target completely\n                        callbacks.delete(target);\n                        observer.unobserve(target);\n                        // if not tracked elements left - disconnect observer\n                        if (!callbacks.size) {\n                            observer.disconnect();\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            rootObservers.delete(opt);\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            if (!rootObservers.size) {\n                                observers.delete(root);\n                            }\n                        }\n                    }\n                }\n            },\n        };\n        rootObservers.set(opt, entry);\n    }\n    return entry;\n};\n/**\n * Tracks intersection of a target element with an ancestor element or with a\n * top-level document's viewport.\n *\n * @param target React reference or Element to track.\n * @param options Like `IntersectionObserver` options but `root` can also be\n * react reference\n */\nexport function useIntersectionObserver(target, { threshold = DEFAULT_THRESHOLD, root: r, rootMargin = DEFAULT_ROOT_MARGIN, } = {}) {\n    const [state, setState] = useState();\n    useEffect(() => {\n        const tgt = target && 'current' in target ? target.current : target;\n        if (!tgt)\n            return;\n        let subscribed = true;\n        const observerEntry = getObserverEntry({\n            root: r && 'current' in r ? r.current : r,\n            rootMargin,\n            threshold,\n        });\n        const handler = (entry) => {\n            // it is reinsurance for the highly asynchronous invocations, almost\n            // impossible to achieve in tests, thus excluding from LOC\n            /* istanbul ignore else */\n            if (subscribed) {\n                setState(entry);\n            }\n        };\n        observerEntry.observe(tgt, handler);\n        return () => {\n            subscribed = false;\n            observerEntry.unobserve(tgt, handler);\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [target, r, rootMargin, ...threshold]);\n    return state;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}