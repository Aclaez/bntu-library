{"ast":null,"code":"import _objectSpread from \"C:/Users/trs_user/Documents/my/bntu-library/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/Users/trs_user/Documents/my/bntu-library/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useMemo, useRef, useState } from 'react';\nimport { useSyncedRef } from '../useSyncedRef';\n/**\n * Tracks the result and errors of the provided async function and provides handles to control its execution.\n *\n * @param asyncFn Function that returns a promise.\n * @param initialValue Value that will be set on initialisation before the async function is\n * executed.\n */\nexport function useAsync(asyncFn, initialValue) {\n  var _useState = useState({\n      status: 'not-executed',\n      error: undefined,\n      result: initialValue\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    state = _useState2[0],\n    setState = _useState2[1];\n  var promiseRef = useRef();\n  var argsRef = useRef();\n  var methods = useSyncedRef({\n    execute: function execute() {\n      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n        params[_key] = arguments[_key];\n      }\n      argsRef.current = params;\n      var promise = asyncFn.apply(void 0, params);\n      promiseRef.current = promise;\n      setState(function (s) {\n        return _objectSpread(_objectSpread({}, s), {}, {\n          status: 'loading'\n        });\n      });\n      // eslint-disable-next-line promise/catch-or-return\n      promise.then(function (result) {\n        // we dont want to handle result/error of non-latest function\n        // this approach helps to avoid race conditions\n        // eslint-disable-next-line promise/always-return\n        if (promise === promiseRef.current) {\n          setState(function (s) {\n            return _objectSpread(_objectSpread({}, s), {}, {\n              status: 'success',\n              error: undefined,\n              result: result\n            });\n          });\n        }\n      }, function (error) {\n        // we dont want to handle result/error of non-latest function\n        // this approach helps to avoid race conditions\n        if (promise === promiseRef.current) {\n          setState(function (s) {\n            return _objectSpread(_objectSpread({}, s), {}, {\n              status: 'error',\n              error: error\n            });\n          });\n        }\n      });\n      return promise;\n    },\n    reset: function reset() {\n      setState({\n        status: 'not-executed',\n        error: undefined,\n        result: initialValue\n      });\n      promiseRef.current = undefined;\n      argsRef.current = undefined;\n    }\n  });\n  return [state, useMemo(function () {\n    return {\n      reset: function reset() {\n        methods.current.reset();\n      },\n      execute: function execute() {\n        var _methods$current;\n        return (_methods$current = methods.current).execute.apply(_methods$current, arguments);\n      }\n    };\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []), {\n    promise: promiseRef.current,\n    lastArgs: argsRef.current\n  }];\n}","map":{"version":3,"names":["useMemo","useRef","useState","useSyncedRef","useAsync","asyncFn","initialValue","_useState","status","error","undefined","result","_useState2","_slicedToArray","state","setState","promiseRef","argsRef","methods","execute","_len","arguments","length","params","Array","_key","current","promise","apply","s","_objectSpread","then","reset","_methods$current","lastArgs"],"sources":["C:/Users/trs_user/Documents/my/bntu-library/node_modules/@react-hookz/web/esm/useAsync/index.js"],"sourcesContent":["import { useMemo, useRef, useState } from 'react';\nimport { useSyncedRef } from '../useSyncedRef';\n/**\n * Tracks the result and errors of the provided async function and provides handles to control its execution.\n *\n * @param asyncFn Function that returns a promise.\n * @param initialValue Value that will be set on initialisation before the async function is\n * executed.\n */\nexport function useAsync(asyncFn, initialValue) {\n    const [state, setState] = useState({\n        status: 'not-executed',\n        error: undefined,\n        result: initialValue,\n    });\n    const promiseRef = useRef();\n    const argsRef = useRef();\n    const methods = useSyncedRef({\n        execute: (...params) => {\n            argsRef.current = params;\n            const promise = asyncFn(...params);\n            promiseRef.current = promise;\n            setState((s) => ({ ...s, status: 'loading' }));\n            // eslint-disable-next-line promise/catch-or-return\n            promise.then((result) => {\n                // we dont want to handle result/error of non-latest function\n                // this approach helps to avoid race conditions\n                // eslint-disable-next-line promise/always-return\n                if (promise === promiseRef.current) {\n                    setState((s) => ({ ...s, status: 'success', error: undefined, result }));\n                }\n            }, (error) => {\n                // we dont want to handle result/error of non-latest function\n                // this approach helps to avoid race conditions\n                if (promise === promiseRef.current) {\n                    setState((s) => ({ ...s, status: 'error', error }));\n                }\n            });\n            return promise;\n        },\n        reset: () => {\n            setState({\n                status: 'not-executed',\n                error: undefined,\n                result: initialValue,\n            });\n            promiseRef.current = undefined;\n            argsRef.current = undefined;\n        },\n    });\n    return [\n        state,\n        useMemo(() => ({\n            reset: () => {\n                methods.current.reset();\n            },\n            execute: (...params) => methods.current.execute(...params),\n        }), \n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        []),\n        { promise: promiseRef.current, lastArgs: argsRef.current },\n    ];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}