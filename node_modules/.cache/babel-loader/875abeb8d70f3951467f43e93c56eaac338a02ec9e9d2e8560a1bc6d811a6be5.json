{"ast":null,"code":"import { useEffect } from 'react';\nimport { useFirstMountState } from '../useFirstMountState';\nimport { useMountEffect } from '../useMountEffect';\nimport { useRafState } from '../useRafState';\nimport { isBrowser } from \"../util/const.js\";\nconst listeners = new Set();\nconst callAllListeners = () => {\n  listeners.forEach(l => {\n    l({\n      width: window.innerWidth,\n      height: window.innerHeight\n    });\n  });\n};\n/**\n * Tracks the inner dimensions of the browser window.\n *\n * @param stateHook State hook that will be used to hold the dimensions of the window.\n * @param measureOnMount If `true`, the size of the window will be measured during the effects\n  stage, after the component has mounted. If `false`, the window size is measured synchronously during\n  the component render. Set this to `true` during SSR.\n */\nexport function useWindowSize() {\n  let stateHook = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : useRafState;\n  let measureOnMount = arguments.length > 1 ? arguments[1] : undefined;\n  const isFirstMount = useFirstMountState();\n  const [size, setSize] = stateHook({\n    width: isFirstMount && isBrowser && !measureOnMount ? window.innerWidth : 0,\n    height: isFirstMount && isBrowser && !measureOnMount ? window.innerHeight : 0\n  });\n  useMountEffect(() => {\n    if (measureOnMount) {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    }\n  });\n  useEffect(() => {\n    if (listeners.size === 0) {\n      window.addEventListener('resize', callAllListeners, {\n        passive: true\n      });\n    }\n    listeners.add(setSize);\n    return () => {\n      listeners.delete(setSize);\n      if (listeners.size === 0) {\n        window.removeEventListener('resize', callAllListeners);\n      }\n    };\n  }, [setSize]);\n  return size;\n}","map":{"version":3,"names":["useEffect","useFirstMountState","useMountEffect","useRafState","isBrowser","listeners","Set","callAllListeners","forEach","l","width","window","innerWidth","height","innerHeight","useWindowSize","stateHook","arguments","length","undefined","measureOnMount","isFirstMount","size","setSize","addEventListener","passive","add","delete","removeEventListener"],"sources":["C:/Users/trs_user/Documents/my/bntu-library/node_modules/@react-hookz/web/esm/useWindowSize/index.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { useFirstMountState } from '../useFirstMountState';\nimport { useMountEffect } from '../useMountEffect';\nimport { useRafState } from '../useRafState';\nimport { isBrowser } from \"../util/const.js\";\nconst listeners = new Set();\nconst callAllListeners = () => {\n    listeners.forEach((l) => {\n        l({\n            width: window.innerWidth,\n            height: window.innerHeight,\n        });\n    });\n};\n/**\n * Tracks the inner dimensions of the browser window.\n *\n * @param stateHook State hook that will be used to hold the dimensions of the window.\n * @param measureOnMount If `true`, the size of the window will be measured during the effects\n  stage, after the component has mounted. If `false`, the window size is measured synchronously during\n  the component render. Set this to `true` during SSR.\n */\nexport function useWindowSize(stateHook = useRafState, measureOnMount) {\n    const isFirstMount = useFirstMountState();\n    const [size, setSize] = stateHook({\n        width: isFirstMount && isBrowser && !measureOnMount ? window.innerWidth : 0,\n        height: isFirstMount && isBrowser && !measureOnMount ? window.innerHeight : 0,\n    });\n    useMountEffect(() => {\n        if (measureOnMount) {\n            setSize({\n                width: window.innerWidth,\n                height: window.innerHeight,\n            });\n        }\n    });\n    useEffect(() => {\n        if (listeners.size === 0) {\n            window.addEventListener('resize', callAllListeners, { passive: true });\n        }\n        listeners.add(setSize);\n        return () => {\n            listeners.delete(setSize);\n            if (listeners.size === 0) {\n                window.removeEventListener('resize', callAllListeners);\n            }\n        };\n    }, [setSize]);\n    return size;\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,OAAO;AACjC,SAASC,kBAAkB,QAAQ,uBAAuB;AAC1D,SAASC,cAAc,QAAQ,mBAAmB;AAClD,SAASC,WAAW,QAAQ,gBAAgB;AAC5C,SAASC,SAAS,QAAQ,kBAAkB;AAC5C,MAAMC,SAAS,GAAG,IAAIC,GAAG,EAAE;AAC3B,MAAMC,gBAAgB,GAAGA,CAAA,KAAM;EAC3BF,SAAS,CAACG,OAAO,CAAEC,CAAC,IAAK;IACrBA,CAAC,CAAC;MACEC,KAAK,EAAEC,MAAM,CAACC,UAAU;MACxBC,MAAM,EAAEF,MAAM,CAACG;IACnB,CAAC,CAAC;EACN,CAAC,CAAC;AACN,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAAA,EAA0C;EAAA,IAAzCC,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGd,WAAW;EAAA,IAAEiB,cAAc,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EACjE,MAAME,YAAY,GAAGpB,kBAAkB,EAAE;EACzC,MAAM,CAACqB,IAAI,EAAEC,OAAO,CAAC,GAAGP,SAAS,CAAC;IAC9BN,KAAK,EAAEW,YAAY,IAAIjB,SAAS,IAAI,CAACgB,cAAc,GAAGT,MAAM,CAACC,UAAU,GAAG,CAAC;IAC3EC,MAAM,EAAEQ,YAAY,IAAIjB,SAAS,IAAI,CAACgB,cAAc,GAAGT,MAAM,CAACG,WAAW,GAAG;EAChF,CAAC,CAAC;EACFZ,cAAc,CAAC,MAAM;IACjB,IAAIkB,cAAc,EAAE;MAChBG,OAAO,CAAC;QACJb,KAAK,EAAEC,MAAM,CAACC,UAAU;QACxBC,MAAM,EAAEF,MAAM,CAACG;MACnB,CAAC,CAAC;IACN;EACJ,CAAC,CAAC;EACFd,SAAS,CAAC,MAAM;IACZ,IAAIK,SAAS,CAACiB,IAAI,KAAK,CAAC,EAAE;MACtBX,MAAM,CAACa,gBAAgB,CAAC,QAAQ,EAAEjB,gBAAgB,EAAE;QAAEkB,OAAO,EAAE;MAAK,CAAC,CAAC;IAC1E;IACApB,SAAS,CAACqB,GAAG,CAACH,OAAO,CAAC;IACtB,OAAO,MAAM;MACTlB,SAAS,CAACsB,MAAM,CAACJ,OAAO,CAAC;MACzB,IAAIlB,SAAS,CAACiB,IAAI,KAAK,CAAC,EAAE;QACtBX,MAAM,CAACiB,mBAAmB,CAAC,QAAQ,EAAErB,gBAAgB,CAAC;MAC1D;IACJ,CAAC;EACL,CAAC,EAAE,CAACgB,OAAO,CAAC,CAAC;EACb,OAAOD,IAAI;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}