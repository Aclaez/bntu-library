{"ast":null,"code":"import _toConsumableArray from \"C:/Users/trs_user/Documents/my/bntu-library/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"C:/Users/trs_user/Documents/my/bntu-library/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useEffect, useState } from 'react';\nvar DEFAULT_THRESHOLD = [0];\nvar DEFAULT_ROOT_MARGIN = '0px';\nvar observers = new Map();\nvar getObserverEntry = function getObserverEntry(options) {\n  var _options$root;\n  var root = (_options$root = options.root) !== null && _options$root !== void 0 ? _options$root : document;\n  var rootObservers = observers.get(root);\n  if (!rootObservers) {\n    rootObservers = new Map();\n    observers.set(root, rootObservers);\n  }\n  var opt = JSON.stringify([options.rootMargin, options.threshold]);\n  var entry = rootObservers.get(opt);\n  if (!entry) {\n    var callbacks = new Map();\n    var observer = new IntersectionObserver(function (entries) {\n      return entries.forEach(function (e) {\n        var _callbacks$get;\n        return (_callbacks$get = callbacks.get(e.target)) === null || _callbacks$get === void 0 ? void 0 : _callbacks$get.forEach(function (cb) {\n          return setTimeout(function () {\n            return cb(e);\n          }, 0);\n        });\n      });\n    }, options);\n    entry = {\n      observer: observer,\n      observe: function observe(target, callback) {\n        var cbs = callbacks.get(target);\n        if (!cbs) {\n          // if target has no observers yet - register it\n          cbs = new Set();\n          callbacks.set(target, cbs);\n          observer.observe(target);\n        }\n        // as Set is duplicate-safe - simply add callback on each call\n        cbs.add(callback);\n      },\n      unobserve: function unobserve(target, callback) {\n        var cbs = callbacks.get(target);\n        // else branch should never occur in case of normal execution\n        // because callbacks map is hidden in closure - it is impossible to\n        // simulate situation with non-existent `cbs` Set\n        /* istanbul ignore else */\n        if (cbs) {\n          // remove current observer\n          cbs.delete(callback);\n          if (!cbs.size) {\n            // if no observers left unregister target completely\n            callbacks.delete(target);\n            observer.unobserve(target);\n            // if not tracked elements left - disconnect observer\n            if (!callbacks.size) {\n              observer.disconnect();\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              rootObservers.delete(opt);\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              if (!rootObservers.size) {\n                observers.delete(root);\n              }\n            }\n          }\n        }\n      }\n    };\n    rootObservers.set(opt, entry);\n  }\n  return entry;\n};\n/**\n * Tracks intersection of a target element with an ancestor element or with a\n * top-level document's viewport.\n *\n * @param target React reference or Element to track.\n * @param options Like `IntersectionObserver` options but `root` can also be\n * react reference\n */\nexport function useIntersectionObserver(target) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$threshold = _ref.threshold,\n    threshold = _ref$threshold === void 0 ? DEFAULT_THRESHOLD : _ref$threshold,\n    r = _ref.root,\n    _ref$rootMargin = _ref.rootMargin,\n    rootMargin = _ref$rootMargin === void 0 ? DEFAULT_ROOT_MARGIN : _ref$rootMargin;\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    state = _useState2[0],\n    setState = _useState2[1];\n  useEffect(function () {\n    var tgt = target && 'current' in target ? target.current : target;\n    if (!tgt) return;\n    var subscribed = true;\n    var observerEntry = getObserverEntry({\n      root: r && 'current' in r ? r.current : r,\n      rootMargin: rootMargin,\n      threshold: threshold\n    });\n    var handler = function handler(entry) {\n      // it is reinsurance for the highly asynchronous invocations, almost\n      // impossible to achieve in tests, thus excluding from LOC\n      /* istanbul ignore else */\n      if (subscribed) {\n        setState(entry);\n      }\n    };\n    observerEntry.observe(tgt, handler);\n    return function () {\n      subscribed = false;\n      observerEntry.unobserve(tgt, handler);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [target, r, rootMargin].concat(_toConsumableArray(threshold)));\n  return state;\n}","map":{"version":3,"names":["useEffect","useState","DEFAULT_THRESHOLD","DEFAULT_ROOT_MARGIN","observers","Map","getObserverEntry","options","_options$root","root","document","rootObservers","get","set","opt","JSON","stringify","rootMargin","threshold","entry","callbacks","observer","IntersectionObserver","entries","forEach","e","_callbacks$get","target","cb","setTimeout","observe","callback","cbs","Set","add","unobserve","delete","size","disconnect","useIntersectionObserver","_ref","arguments","length","undefined","_ref$threshold","r","_ref$rootMargin","_useState","_useState2","_slicedToArray","state","setState","tgt","current","subscribed","observerEntry","handler","concat","_toConsumableArray"],"sources":["C:/Users/trs_user/Documents/my/bntu-library/node_modules/@react-hookz/web/esm/useIntersectionObserver/index.js"],"sourcesContent":["import { useEffect, useState } from 'react';\nconst DEFAULT_THRESHOLD = [0];\nconst DEFAULT_ROOT_MARGIN = '0px';\nconst observers = new Map();\nconst getObserverEntry = (options) => {\n    const root = options.root ?? document;\n    let rootObservers = observers.get(root);\n    if (!rootObservers) {\n        rootObservers = new Map();\n        observers.set(root, rootObservers);\n    }\n    const opt = JSON.stringify([options.rootMargin, options.threshold]);\n    let entry = rootObservers.get(opt);\n    if (!entry) {\n        const callbacks = new Map();\n        const observer = new IntersectionObserver((entries) => entries.forEach((e) => callbacks.get(e.target)?.forEach((cb) => setTimeout(() => cb(e), 0))), options);\n        entry = {\n            observer,\n            observe(target, callback) {\n                let cbs = callbacks.get(target);\n                if (!cbs) {\n                    // if target has no observers yet - register it\n                    cbs = new Set();\n                    callbacks.set(target, cbs);\n                    observer.observe(target);\n                }\n                // as Set is duplicate-safe - simply add callback on each call\n                cbs.add(callback);\n            },\n            unobserve(target, callback) {\n                const cbs = callbacks.get(target);\n                // else branch should never occur in case of normal execution\n                // because callbacks map is hidden in closure - it is impossible to\n                // simulate situation with non-existent `cbs` Set\n                /* istanbul ignore else */\n                if (cbs) {\n                    // remove current observer\n                    cbs.delete(callback);\n                    if (!cbs.size) {\n                        // if no observers left unregister target completely\n                        callbacks.delete(target);\n                        observer.unobserve(target);\n                        // if not tracked elements left - disconnect observer\n                        if (!callbacks.size) {\n                            observer.disconnect();\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            rootObservers.delete(opt);\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            if (!rootObservers.size) {\n                                observers.delete(root);\n                            }\n                        }\n                    }\n                }\n            },\n        };\n        rootObservers.set(opt, entry);\n    }\n    return entry;\n};\n/**\n * Tracks intersection of a target element with an ancestor element or with a\n * top-level document's viewport.\n *\n * @param target React reference or Element to track.\n * @param options Like `IntersectionObserver` options but `root` can also be\n * react reference\n */\nexport function useIntersectionObserver(target, { threshold = DEFAULT_THRESHOLD, root: r, rootMargin = DEFAULT_ROOT_MARGIN, } = {}) {\n    const [state, setState] = useState();\n    useEffect(() => {\n        const tgt = target && 'current' in target ? target.current : target;\n        if (!tgt)\n            return;\n        let subscribed = true;\n        const observerEntry = getObserverEntry({\n            root: r && 'current' in r ? r.current : r,\n            rootMargin,\n            threshold,\n        });\n        const handler = (entry) => {\n            // it is reinsurance for the highly asynchronous invocations, almost\n            // impossible to achieve in tests, thus excluding from LOC\n            /* istanbul ignore else */\n            if (subscribed) {\n                setState(entry);\n            }\n        };\n        observerEntry.observe(tgt, handler);\n        return () => {\n            subscribed = false;\n            observerEntry.unobserve(tgt, handler);\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [target, r, rootMargin, ...threshold]);\n    return state;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}