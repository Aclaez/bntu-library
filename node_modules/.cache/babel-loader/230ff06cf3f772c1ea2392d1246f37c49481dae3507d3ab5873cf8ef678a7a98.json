{"ast":null,"code":"import { useMemo, useRef, useState } from 'react';\nimport { useSyncedRef } from '../useSyncedRef';\n/**\n * Tracks the result and errors of the provided async function and provides handles to control its execution.\n *\n * @param asyncFn Function that returns a promise.\n * @param initialValue Value that will be set on initialisation before the async function is\n * executed.\n */\nexport function useAsync(asyncFn, initialValue) {\n  const [state, setState] = useState({\n    status: 'not-executed',\n    error: undefined,\n    result: initialValue\n  });\n  const promiseRef = useRef();\n  const argsRef = useRef();\n  const methods = useSyncedRef({\n    execute: function () {\n      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n        params[_key] = arguments[_key];\n      }\n      argsRef.current = params;\n      const promise = asyncFn(...params);\n      promiseRef.current = promise;\n      setState(s => ({\n        ...s,\n        status: 'loading'\n      }));\n      // eslint-disable-next-line promise/catch-or-return\n      promise.then(result => {\n        // we dont want to handle result/error of non-latest function\n        // this approach helps to avoid race conditions\n        // eslint-disable-next-line promise/always-return\n        if (promise === promiseRef.current) {\n          setState(s => ({\n            ...s,\n            status: 'success',\n            error: undefined,\n            result\n          }));\n        }\n      }, error => {\n        // we dont want to handle result/error of non-latest function\n        // this approach helps to avoid race conditions\n        if (promise === promiseRef.current) {\n          setState(s => ({\n            ...s,\n            status: 'error',\n            error\n          }));\n        }\n      });\n      return promise;\n    },\n    reset: () => {\n      setState({\n        status: 'not-executed',\n        error: undefined,\n        result: initialValue\n      });\n      promiseRef.current = undefined;\n      argsRef.current = undefined;\n    }\n  });\n  return [state, useMemo(() => ({\n    reset: () => {\n      methods.current.reset();\n    },\n    execute: function () {\n      return methods.current.execute(...arguments);\n    }\n  }),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []), {\n    promise: promiseRef.current,\n    lastArgs: argsRef.current\n  }];\n}","map":{"version":3,"names":["useMemo","useRef","useState","useSyncedRef","useAsync","asyncFn","initialValue","state","setState","status","error","undefined","result","promiseRef","argsRef","methods","execute","_len","arguments","length","params","Array","_key","current","promise","s","then","reset","lastArgs"],"sources":["C:/Users/trs_user/Documents/my/bntu-library/node_modules/@react-hookz/web/esm/useAsync/index.js"],"sourcesContent":["import { useMemo, useRef, useState } from 'react';\nimport { useSyncedRef } from '../useSyncedRef';\n/**\n * Tracks the result and errors of the provided async function and provides handles to control its execution.\n *\n * @param asyncFn Function that returns a promise.\n * @param initialValue Value that will be set on initialisation before the async function is\n * executed.\n */\nexport function useAsync(asyncFn, initialValue) {\n    const [state, setState] = useState({\n        status: 'not-executed',\n        error: undefined,\n        result: initialValue,\n    });\n    const promiseRef = useRef();\n    const argsRef = useRef();\n    const methods = useSyncedRef({\n        execute: (...params) => {\n            argsRef.current = params;\n            const promise = asyncFn(...params);\n            promiseRef.current = promise;\n            setState((s) => ({ ...s, status: 'loading' }));\n            // eslint-disable-next-line promise/catch-or-return\n            promise.then((result) => {\n                // we dont want to handle result/error of non-latest function\n                // this approach helps to avoid race conditions\n                // eslint-disable-next-line promise/always-return\n                if (promise === promiseRef.current) {\n                    setState((s) => ({ ...s, status: 'success', error: undefined, result }));\n                }\n            }, (error) => {\n                // we dont want to handle result/error of non-latest function\n                // this approach helps to avoid race conditions\n                if (promise === promiseRef.current) {\n                    setState((s) => ({ ...s, status: 'error', error }));\n                }\n            });\n            return promise;\n        },\n        reset: () => {\n            setState({\n                status: 'not-executed',\n                error: undefined,\n                result: initialValue,\n            });\n            promiseRef.current = undefined;\n            argsRef.current = undefined;\n        },\n    });\n    return [\n        state,\n        useMemo(() => ({\n            reset: () => {\n                methods.current.reset();\n            },\n            execute: (...params) => methods.current.execute(...params),\n        }), \n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        []),\n        { promise: promiseRef.current, lastArgs: argsRef.current },\n    ];\n}\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AACjD,SAASC,YAAY,QAAQ,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,QAAQA,CAACC,OAAO,EAAEC,YAAY,EAAE;EAC5C,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGN,QAAQ,CAAC;IAC/BO,MAAM,EAAE,cAAc;IACtBC,KAAK,EAAEC,SAAS;IAChBC,MAAM,EAAEN;EACZ,CAAC,CAAC;EACF,MAAMO,UAAU,GAAGZ,MAAM,EAAE;EAC3B,MAAMa,OAAO,GAAGb,MAAM,EAAE;EACxB,MAAMc,OAAO,GAAGZ,YAAY,CAAC;IACzBa,OAAO,EAAE,SAAAA,CAAA,EAAe;MAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAXC,MAAM,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;QAANF,MAAM,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;MAAA;MACfR,OAAO,CAACS,OAAO,GAAGH,MAAM;MACxB,MAAMI,OAAO,GAAGnB,OAAO,CAAC,GAAGe,MAAM,CAAC;MAClCP,UAAU,CAACU,OAAO,GAAGC,OAAO;MAC5BhB,QAAQ,CAAEiB,CAAC,KAAM;QAAE,GAAGA,CAAC;QAAEhB,MAAM,EAAE;MAAU,CAAC,CAAC,CAAC;MAC9C;MACAe,OAAO,CAACE,IAAI,CAAEd,MAAM,IAAK;QACrB;QACA;QACA;QACA,IAAIY,OAAO,KAAKX,UAAU,CAACU,OAAO,EAAE;UAChCf,QAAQ,CAAEiB,CAAC,KAAM;YAAE,GAAGA,CAAC;YAAEhB,MAAM,EAAE,SAAS;YAAEC,KAAK,EAAEC,SAAS;YAAEC;UAAO,CAAC,CAAC,CAAC;QAC5E;MACJ,CAAC,EAAGF,KAAK,IAAK;QACV;QACA;QACA,IAAIc,OAAO,KAAKX,UAAU,CAACU,OAAO,EAAE;UAChCf,QAAQ,CAAEiB,CAAC,KAAM;YAAE,GAAGA,CAAC;YAAEhB,MAAM,EAAE,OAAO;YAAEC;UAAM,CAAC,CAAC,CAAC;QACvD;MACJ,CAAC,CAAC;MACF,OAAOc,OAAO;IAClB,CAAC;IACDG,KAAK,EAAEA,CAAA,KAAM;MACTnB,QAAQ,CAAC;QACLC,MAAM,EAAE,cAAc;QACtBC,KAAK,EAAEC,SAAS;QAChBC,MAAM,EAAEN;MACZ,CAAC,CAAC;MACFO,UAAU,CAACU,OAAO,GAAGZ,SAAS;MAC9BG,OAAO,CAACS,OAAO,GAAGZ,SAAS;IAC/B;EACJ,CAAC,CAAC;EACF,OAAO,CACHJ,KAAK,EACLP,OAAO,CAAC,OAAO;IACX2B,KAAK,EAAEA,CAAA,KAAM;MACTZ,OAAO,CAACQ,OAAO,CAACI,KAAK,EAAE;IAC3B,CAAC;IACDX,OAAO,EAAE,SAAAA,CAAA;MAAA,OAAeD,OAAO,CAACQ,OAAO,CAACP,OAAO,CAAC,GAAAE,SAAS,CAAC;IAAA;EAC9D,CAAC,CAAC;EACF;EACA,EAAE,CAAC,EACH;IAAEM,OAAO,EAAEX,UAAU,CAACU,OAAO;IAAEK,QAAQ,EAAEd,OAAO,CAACS;EAAQ,CAAC,CAC7D;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}