{"ast":null,"code":"import { useEffect } from 'react';\nimport { useSyncedRef } from '../useSyncedRef';\nimport { isBrowser } from \"../util/const.js\";\nlet observerSingleton;\nfunction getResizeObserver() {\n  if (!isBrowser) return undefined;\n  if (observerSingleton) return observerSingleton;\n  const callbacks = new Map();\n  const observer = new ResizeObserver(entries => {\n    entries.forEach(entry => callbacks.get(entry.target)?.forEach(cb => setTimeout(() => cb(entry), 0)));\n  });\n  observerSingleton = {\n    observer,\n    subscribe: (target, callback) => {\n      let cbs = callbacks.get(target);\n      if (!cbs) {\n        // if target has no observers yet - register it\n        cbs = new Set();\n        callbacks.set(target, cbs);\n        observer.observe(target);\n      }\n      // as Set is duplicate-safe - simply add callback on each call\n      cbs.add(callback);\n    },\n    unsubscribe: (target, callback) => {\n      const cbs = callbacks.get(target);\n      // else branch should never occur in case of normal execution\n      // because callbacks map is hidden in closure - it is impossible to\n      // simulate situation with non-existent `cbs` Set\n      /* istanbul ignore else */\n      if (cbs) {\n        // remove current observer\n        cbs.delete(callback);\n        if (!cbs.size) {\n          // if no observers left unregister target completely\n          callbacks.delete(target);\n          observer.unobserve(target);\n        }\n      }\n    }\n  };\n  return observerSingleton;\n}\n/**\n * Invokes a callback whenever ResizeObserver detects a change to target's size.\n *\n * @param target React reference or Element to track.\n * @param callback Callback that will be invoked on resize.\n * @param enabled Whether resize observer is enabled or not.\n */\nexport function useResizeObserver(target, callback) {\n  let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const ro = enabled && getResizeObserver();\n  const cb = useSyncedRef(callback);\n  const tgt = target && 'current' in target ? target.current : target;\n  useEffect(() => {\n    // this secondary target resolve required for case when we receive ref object, which, most\n    // likely, contains null during render stage, but already populated with element during\n    // effect stage.\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const tgt = target && 'current' in target ? target.current : target;\n    if (!ro || !tgt) return;\n    // as unsubscription in internals of our ResizeObserver abstraction can\n    // happen a bit later than effect cleanup invocation - we need a marker,\n    // that this handler should not be invoked anymore\n    let subscribed = true;\n    const handler = function () {\n      // it is reinsurance for the highly asynchronous invocations, almost\n      // impossible to achieve in tests, thus excluding from LOC\n      /* istanbul ignore else */\n      if (subscribed) {\n        cb.current(...arguments);\n      }\n    };\n    ro.subscribe(tgt, handler);\n    return () => {\n      subscribed = false;\n      ro.unsubscribe(tgt, handler);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [tgt, ro]);\n}","map":{"version":3,"names":["useEffect","useSyncedRef","isBrowser","observerSingleton","getResizeObserver","undefined","callbacks","Map","observer","ResizeObserver","entries","forEach","entry","get","target","cb","setTimeout","subscribe","callback","cbs","Set","set","observe","add","unsubscribe","delete","size","unobserve","useResizeObserver","enabled","arguments","length","ro","tgt","current","subscribed","handler"],"sources":["C:/Users/trs_user/Documents/my/bntu-library/node_modules/@react-hookz/web/esm/useResizeObserver/index.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { useSyncedRef } from '../useSyncedRef';\nimport { isBrowser } from \"../util/const.js\";\nlet observerSingleton;\nfunction getResizeObserver() {\n    if (!isBrowser)\n        return undefined;\n    if (observerSingleton)\n        return observerSingleton;\n    const callbacks = new Map();\n    const observer = new ResizeObserver((entries) => {\n        entries.forEach((entry) => callbacks.get(entry.target)?.forEach((cb) => setTimeout(() => cb(entry), 0)));\n    });\n    observerSingleton = {\n        observer,\n        subscribe: (target, callback) => {\n            let cbs = callbacks.get(target);\n            if (!cbs) {\n                // if target has no observers yet - register it\n                cbs = new Set();\n                callbacks.set(target, cbs);\n                observer.observe(target);\n            }\n            // as Set is duplicate-safe - simply add callback on each call\n            cbs.add(callback);\n        },\n        unsubscribe: (target, callback) => {\n            const cbs = callbacks.get(target);\n            // else branch should never occur in case of normal execution\n            // because callbacks map is hidden in closure - it is impossible to\n            // simulate situation with non-existent `cbs` Set\n            /* istanbul ignore else */\n            if (cbs) {\n                // remove current observer\n                cbs.delete(callback);\n                if (!cbs.size) {\n                    // if no observers left unregister target completely\n                    callbacks.delete(target);\n                    observer.unobserve(target);\n                }\n            }\n        },\n    };\n    return observerSingleton;\n}\n/**\n * Invokes a callback whenever ResizeObserver detects a change to target's size.\n *\n * @param target React reference or Element to track.\n * @param callback Callback that will be invoked on resize.\n * @param enabled Whether resize observer is enabled or not.\n */\nexport function useResizeObserver(target, callback, enabled = true) {\n    const ro = enabled && getResizeObserver();\n    const cb = useSyncedRef(callback);\n    const tgt = target && 'current' in target ? target.current : target;\n    useEffect(() => {\n        // this secondary target resolve required for case when we receive ref object, which, most\n        // likely, contains null during render stage, but already populated with element during\n        // effect stage.\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const tgt = target && 'current' in target ? target.current : target;\n        if (!ro || !tgt)\n            return;\n        // as unsubscription in internals of our ResizeObserver abstraction can\n        // happen a bit later than effect cleanup invocation - we need a marker,\n        // that this handler should not be invoked anymore\n        let subscribed = true;\n        const handler = (...args) => {\n            // it is reinsurance for the highly asynchronous invocations, almost\n            // impossible to achieve in tests, thus excluding from LOC\n            /* istanbul ignore else */\n            if (subscribed) {\n                cb.current(...args);\n            }\n        };\n        ro.subscribe(tgt, handler);\n        return () => {\n            subscribed = false;\n            ro.unsubscribe(tgt, handler);\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [tgt, ro]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}